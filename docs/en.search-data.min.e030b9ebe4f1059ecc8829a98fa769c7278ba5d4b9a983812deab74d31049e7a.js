'use strict',function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/p2020/docs/01_if_while/',title:"Zmienne, If, While",section:"Docs",content:"Zmienne, if, while #  Arytmetyka #  print(1 + 5) # Wypisz wynik dodawania 1+5 print(5 % 2) # Wypisz resztę z dzielenia 5/2 print(5 % 2 == 0) # Wypisz, czy reszta z dzielenia 5/2 jest równa 0 Operatory #   2 + 2 2 * 2 2 ** 2 10 % 3 - reszta z dzielenia (10 % 3 == 1) 10 / 3 - dzielenie (10 / 3 == 3.33333) 10 // 3 - dzielenie z zaokrągleniem w dół (10 // 3 == 3)  Zmienne #  Podstawową jednostką, na której operują programy w pythonie są zmienne. Używamy ich do przechowywania wartości.\na = 1 print(a) Warto zwrócić uwagę, ze operator = nie oznacza równania, jak w matematyce, ale przypisanie.\na = 1 b = 1 c = a + b print(c) a = 5 print(c) Co ciekawe, dzięki temu, następujące wyrażenie może mieć sens:\na = 1 a = a + 1 print(a) If/Else #  Czasami zachodzi potrzeba wykonania kodu tylko w przypadku, kiedy nasze zmienne mają pewne właściwości. Wykorzystujemy do tego konstrukcję if/else\na = 155 if a % 2 == 0: print(f\u0026#34;{a} jest parzysta\u0026#34;) else: print(f\u0026#34;{a} jest nieparzysta\u0026#34;) While #  Pętli while używamy, kiedy chcemy wykonać kod wielokrotnie. Przeanalizujmy kilka przykładów jej użycia:\n Wypisz wszystkie liczby od 0 do 100  n = 0 # Zaczynamy z n równym 0 while n \u0026lt;= 100: # Wykonuj tak długo, jak długo n jest mniejsze od 0 print(n) # Wypisz n n = n + 1  Wypisz wszystkie liczby mniejsze od 100, ale podzielne przez 3  n = 0 while n \u0026lt; 100: if n % 3 == 0: print(n) n = n + 1  Wypisz sumę liczb od 0 do 100  suma = 0 n = 0 while n \u0026lt;= 100: suma = suma + n n = n + 1 print(suma)  Wypisz sumę liczb mniejszych lub równych 100 i podzielnych przez 3  suma = 0 n = 0 while n \u0026lt;= 100: if n % 3 == 0: suma = suma + n n = n + 1 print(suma)  Sprawdź, czy liczba jest pierwsza  liczba = 157 n = 2 pierwsza = True while n \u0026lt; liczba: if liczba % n == 0: pierwsza = False n = n + 1 if pierwsza: print(\u0026#34;Jest pierwsza\u0026#34;) else: print(\u0026#34;Nie jest pierwsza\u0026#34;) "}),a.add({id:1,href:'/p2020/docs/02_functions/',title:"Funkcje",section:"Docs",content:"Funkcje #  Liczby pierwsze - kontynuacja #  z = 1 while z \u0026lt; n: z = z + 1 if n == z: print(\u0026#34;Ta liczba jest liczbą pierwszą\u0026#34;) break if n % z == 0: print(f\u0026#34;Ta liczba nie jest liczbą pierwszą. Jest podzielna przez {z}\u0026#34;) break Co to jest funkcja? #  Funkcja to podprogram, którego używamy do podzielenia naszego właściwego programu na mniejsze części.\nFunkcje składają się z\n nazwy (suma) argumentów(a, b, c) zawartości return (a + b + c) * 2  def suma(a, b, c): return (a + b + c) * 2 Teraz możemy przenieść kod sprawdzający, czy liczba jest pierwsza do nowej funkcji i nazwać ją jest_pierwsza.\ndef jest_pierwsza(n): z = 1 while z \u0026lt; n: z = z + 1 if n == z: return True if n % z == 0: return False i = 1 while i \u0026lt;= 100: if jest_pierwsza(i): print(i) i = i + 1 "}),a.add({id:2,href:'/p2020/docs/03_string_input_fizzbuzz/',title:"String, Input, Hurra",section:"Docs",content:"String, Input, Hurra #  Typ String #  Zmienne typu int\na = 5 print(type(a)) # \u0026gt;\u0026gt; \u0026#39;int\u0026#39; Zmienne typu string\na = \u0026#34;5\u0026#34; print(type(a)) # \u0026gt;\u0026gt; \u0026#39;str\u0026#39; Konkatenacja - operatorem + możemy łączyć zmienne typu string\na = \u0026#34;Dzień \u0026#34; b = \u0026#34;dobry\u0026#34; print(a + b) # \u0026gt;\u0026gt; Dzień dobry Konwersje - funkcjami int i str możemy konwertować typy zmiennych\na = \u0026#34;1\u0026#34; b = \u0026#34;1\u0026#34; print(a + b) # wypisze 11 print(int(a) + int(b)) # wypisze 2 c = int(a) + int(b) print(\u0026#34;liczba: \u0026#34; + str(c)) # żeby połączyć liczbę int z tekstem, trzeba ją zamienić na str Interpolacja - możemy wstawić zawartość zmiennej bezpośrednio do stringa\na = 5 b = f\u0026#34;2+3={a}\u0026#34; print(b) Mnożenie\na = \u0026#34;ab\u0026#34; * 5 print(a) # \u0026gt;\u0026gt; ababababab Można też użyć znaku ', który jest równoważny \u0026quot;\na = \u0026#39;ab\u0026#39; print(a) Potrójne ''' lub \u0026quot;\u0026quot;\u0026quot; pozwala na zdefiniowanie tekstu składającego się z wielu linii\na = \u0026#39;\u0026#39;\u0026#39; To jest tekst podzielony na wiele linii \u0026#39;\u0026#39;\u0026#39; print (a) Input #  a = int(input()) print(a + 1) Hurra! #  Zadanie https://sio2.mimuw.edu.pl/c/oij14-1/p/hur/ z XIV OIJ\nn = int(input()) i = 1 while i \u0026lt;= n: if i % 7 == 0 and i % 11 == 0: print(\u0026#34;Wiwat!\u0026#34;) elif i % 7 == 0: print(\u0026#34;Hurra!\u0026#34;) elif i % 11 == 0: print(\u0026#34;Super!\u0026#34;) else: print(i) i = i + 1 "}),a.add({id:3,href:'/p2020/docs/04_for_list/',title:"For, List",section:"Docs",content:"Pętla for, listy #  Pętla for #  W niektórych przypadkach zamiast pętli while możemy użyć prostszej pętli for\nWeźmy program, który liczy iloczyn liczb od 1 do 5 z pętlą while\ni = 1 iloczyn = 1 while i \u0026lt;= 5: iloczyn = iloczyn * i i = i + 1 print(iloczyn) W tym przypadku musimy pamiętać o przypisaniu wartości 0 do zmiennej i, oraz o zwiększaniu jej wartości w odpowiednim miejscu.\nZ pętlą for możemy to uzyskać automatycznie\niloczyn = 1 for i in range(1, 6): iloczyn = iloczyn * i print(iloczyn) Pętla wykona kod iloczyn = iloczyn * i pięciokrotnie, za każdym razem zmieniając wartość i na kolejne liczby z przedziału (1,6). Warto zwrócić uwagę, że przedział jest prawostronnie otwarty, czyli nie zawiera ostatniej liczby.\nFunkcja range występuje w trzech wariantach:\n jednoargumentowym range(n), zwracającym liczby od 0 do n-1  for i in range(5): print(i) na wyjściu otrzymujemy\n0 1 2 3 4  dwuargumentowym range(n,m) zwracającym liczby od n do m-1  for i in range(2, 5): print(i) na wyjściu otrzymujemy\n2 3 4  trzyargumentowym range(n, m, k) zwracającym liczby od n do m-1, ale iterującym co k  for i in range(2, 15, 4): print(i) Na wyjściu otrzymujemy:\n2 6 10 14 Listy #  Lista to typ zmiennej, który umożliwia nam przechowanie kilku wartości:\n tworzenie listy a = [1, 2, 3] pierwszy element a[0] drugi element a[1] długość listy: len(a) ostatni element listy: a[len(a) - 1] lub a[-1] tworzenie listy składającej się z takich samych elementów a = [1] * 100  Przykład: wypisanie iloczynu elementów listy [11, 22, 33]:\nl = [11, 22, 33] n = len(l) iloczyn = 1 for i in range(0, n): a = l[i] iloczyn = iloczyn * a print(iloczyn) "}),a.add({id:4,href:'/p2020/docs/05_input/',title:"Input",section:"Docs",content:"Input #  Pojedynczy string wczytujemy po prostu funkcją input\nwejscie = input() # in \u0026gt;\u0026gt; abc print(wejscie + \u0026#34;d\u0026#34;) # out\u0026lt;\u0026lt; abcd Jeżeli chcemy wczytać zmienną typu int, należy pamiętać o konwersji\ni = int(input()) # in \u0026gt;\u0026gt; 6 print(i + 1) # out\u0026lt;\u0026lt; 7 Jeżeli chcemy odczytać sekwencję stringów oddzieloną spacjami, należy użyć metody .split()\nwejscie = input().split() # in \u0026gt;\u0026gt; abc def ghi  print(wejscie) # out\u0026lt;\u0026lt; [\u0026#39;abc\u0026#39;, \u0026#39;def\u0026#39;, \u0026#39;ghi\u0026#39;] Jeżeli natomiast chcemy odczytać sekwencję intów, należy najpierw wczytać je jako wartości string a następnie przekonwertować do int\ntablica_stringow = input().split() tablica_intow = [] for i in range(len(tablica_stringow)): tablica_intow.append(int(tablica_stringow[i])) print(tablica_intow) # in \u0026gt;\u0026gt; 1 2 3 4 5 # out\u0026lt;\u0026lt; [\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;] Można też użyć skróconej wersji\ntablica = [int(x) for x in input().split()] print(tablica) # in\u0026gt;\u0026gt; 1 2 3 4 5 # out \u0026lt;\u0026lt; [1, 2, 3, 4, 5] "}),a.add({id:5,href:'/p2020/docs/06_list_2/',title:"List 2",section:"Docs",content:"List 2 #  Wyszukiwanie indeksu: #  a = [1,2,3,4] print(a.index(4)) # \u0026lt;\u0026lt; 3 Najmniejszy/największy element: #  a = [1, 2, 3, 4] print(max(a)) print(min(a)) # \u0026lt;\u0026lt; 4 # \u0026lt;\u0026lt; 1 Potęgowanie #  x = 2**4 # == 16 "}),a.add({id:6,href:'/p2020/docs/07_binary_search/',title:"Binary search",section:"Docs",content:"from time import time tablica = [3, 5, 10, 11, 19, 25, 31, 35, 36] tablica = list(range(1,1000003,3)) szukana = 10000000000000000 t1 = time() # ALGORYTM 1 for i in range(len(tablica)): if tablica[i] == szukana: print(\u0026#34;Jest\u0026#34;) break elif i + 1 == len(tablica): print(\u0026#34;Nie ma\u0026#34;) t2 = time() print(f\u0026#34;Algorytm wykonywal sie {t2-t1:f}\u0026#34;) # ALGORYTM 2 t3 = time() poczatek = 0 koniec =len(tablica) while poczatek != koniec: srodek = (poczatek + koniec) // 2 if tablica[srodek] == szukana: print(\u0026#34;Jest\u0026#34;) break elif srodek == poczatek: print(\u0026#34;Nie ma\u0026#34;) break elif tablica[srodek] \u0026lt; szukana: poczatek = srodek else: koniec = srodek t4 = time() print(f\u0026#34;Algorytm 2 wykonywal sie {t4 - t3:f}\u0026#34;) "}),a.add({id:7,href:'/p2020/docs/08_rekurencja/',title:"Rekurencja",section:"Docs",content:"Silnia #  def silnia(n): if n == 0: return 1 else: return n * silnia(n - 1) Potęgowanie #  def potega(a, n): if n == 0: return 1 else: return a * potega(a, n - 1) def potega_szybka(a, n): if n == 0: return 1 if n % 2 == 0: return potega_szybka(a * a, n / 2) else: return a * potega_szybka(a, n - 1) "}),a.add({id:8,href:'/p2020/docs/09_szyfr_cezara/',title:"Szyfr Cezara",section:"Docs",content:"chr, ord #  text = input() klucz = -3 # ascii # ord, chr zaszyfrowany_text = \u0026#34;\u0026#34; for i in range(len(text)): litera = ord(text[i]) numer_litery = litera % 97 nowy_numer_litery = (numer_litery + klucz) % 26 nowy_kod_ascii_litery = nowy_numer_litery + 97 nowa_litera = chr(nowy_kod_ascii_litery) zaszyfrowany_text = zaszyfrowany_text + nowa_litera print(zaszyfrowany_text) "}),a.add({id:9,href:'/p2020/docs/10_fib/',title:"Fibonacci",section:"Docs",content:"# n 0 1 2 3 4 5 6 7 8 # fibonacci(n) 1 1 2 3 5 8 13 21 34 from time import time def fibonacci(n): a = 1 b = 1 for i in range(n - 1): d = b b = a + b a = d return b licznik = 0 def fib(n): global licznik licznik += 1 if n == 0 or n == 1: return 1 else: return fib(n-1) + fib(n-2) print(fib(15)) print(licznik) "}),a.add({id:10,href:'/p2020/docs/11_binary_notation/',title:"Notacja binarna",section:"Docs",content:"def do_formy_dziesietnej(binarna_liczba): a = 0 for i in reversed(range(len(binarna_liczba))): aktualna_potega = 2 ** (len(binarna_liczba) - (i + 1)) if binarna_liczba[i] == \u0026#34;1\u0026#34;: a += aktualna_potega return a x = do_formy_dziesietnej(\u0026#34;1110\u0026#34;) print(x) def z_formy_dziesietnej(n): potega = 1 while n \u0026gt; potega: potega = potega * 2 potega = potega // 2 lista = \u0026#39;\u0026#39; suma = 0 while potega != 0: if suma + potega \u0026lt;= n: lista = lista + \u0026#39;1\u0026#39; suma += potega else: lista = lista + \u0026#39;0\u0026#39; potega = potega // 2 return \u0026#34;\u0026#34;.join(lista) print(z_formy_dziesietnej(19)) "}),a.add({id:11,href:'/p2020/docs/12_sort1/',title:"Sortowanie przez wybieranie",section:"Docs",content:"Algorytm sortowania przez wybieranie #  tablica = [15, 16, 12, 11] posortowana = [] licznik = 0 for j in range(len(tablica)): najmniejsza = tablica[0] index = 0 for i in range(len(tablica)): if najmniejsza \u0026gt;= tablica[i]: najmniejsza = tablica[i] index = i posortowana.append(najmniejsza) del tablica[index] print(posortowana) Złożoność obliczeniowa #  Dla tablicy o długości n wewnętrzna pętla wykona się n + (n-1) + ... + 1 razy.\nMożemy skorzystać ze znanej metody na policzenie tej sumy. Oznaczmy tę sumę jako S.\nWiemy, że:\nn + (n-1) + (n-2) + ... + 1 = S oraz\n1 + 2 + 3 + + n = S Jeżeli dodamy elemeny kolumnami, to dostaniemy:\nn + 1 + (n-1)+2 + (n-2) + 3 + ... + 1 + n = 2*S a zatem:\n(n + 1) + (n + 1) + (n + 1) + ... + (n + 1) = 2*S Czyli\nn * (n+1) = 2*S więc S = (n+1) * n / 2 = ½n² + ½n.\nJeżeli liczba kroków algorytmu ma postać wielomianową, to do wyliczenia jego złożoności obliczeniowej pomijamy wszystko poza najwyższą potęgą W tym przypadku złożoność wynosi n²\n"}),a.add({id:12,href:'/p2020/docs/13_merge_sort/',title:"Merge sort",section:"Docs",content:"def merge(lewa, prawa): ll = len(lewa) lp = len(prawa) posortowana = [] i = 0 j = 0 for _ in range(lp + ll): if (j == lp) or (i != ll and (lewa[i] \u0026lt; prawa[j])): posortowana.append(lewa[i]) i += 1 else: posortowana.append(prawa[j]) j += 1 return posortowana def merge_sort(tablica): if len(tablica) \u0026lt;= 1: return tablica else: a = len(tablica) // 2 prawa = tablica[a:] lewa = tablica[:a] posortowana_lewa = merge_sort(lewa) posortowana_prawa = merge_sort(prawa) return merge(posortowana_lewa, posortowana_prawa) x = merge_sort([5,3,6,2,7,1,7,4]) print(x) "})}()